# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['GH_HOST', 'GhApi', 'EMPTY_TREE_SHA', 'print_summary']

# Cell
from fastcore.utils import *
from fastcore.foundation import *
from fastcore.meta import *

import pprint,inspect,json,copy,urllib,mimetypes,base64
from inspect import signature,Parameter,Signature
from urllib.parse import urlencode
from .metadata import funcs
from urllib.request import Request,urlretrieve
from urllib.error import HTTPError

# Cell
GH_HOST = "https://api.github.com"
_DOC_URL = 'https://docs.github.com/'

# Cell
def _preview_hdr(preview): return {'Accept': f'application/vnd.github.{preview}-preview+json'} if preview else {}

def _mk_param(nm, **kwargs): return Parameter(nm, kind=Parameter.POSITIONAL_OR_KEYWORD, **kwargs)
def _mk_sig(req_args, def_args):
    "Create a signature object with required and default arguments"
    params =  [_mk_param(k) for k in req_args]
    params += [_mk_param(k, default=v) for k,v in def_args.items()]
    return Signature(params)

# Cell
class _GhVerb:
    __slots__ = 'path,verb,tag,name,summary,url,route_ps,params,data,preview,client,__doc__'.split(',')
    def __init__(self, path, verb, oper, summary, url, params, data, preview, client, kwargs):
        tag,name = oper.split('/')
        name = name.replace('-','_')
        path,route_ps,_ = partial_format(path, **kwargs)
        __doc__ = summary
        data = L(data).itemgot(0)
        store_attr()

    def __call__(self, *args, headers=None, **kwargs):
        headers = {**_preview_hdr(self.preview),**(headers or {})}
        flds = [o for o in self.route_ps+self.params+self.data if o not in kwargs]
        for a,b in zip(args,flds): kwargs[b]=a
        kwargs = {k:v for k,v in kwargs.items() if v is not None}
        route_p,query_p,data_p = [{p:kwargs[p] for p in o if p in kwargs}
                                 for o in (self.route_ps,self.params,self.data)]
        return self.client(self.path, self.verb, headers=headers, route=route_p, query=query_p, data=data_p)

    @property
    def __signature__(self): return _mk_sig(self.route_ps, dict.fromkeys(self.params+self.data))
    __call__.__signature__ = __signature__

    def _repr_markdown_(self):
        params = ', '.join(self.route_ps+self.params+self.data)
        return f'[{self.tag}.{self.name}]({_DOC_URL}{self.url.replace(" ","_")})({params}): *{self.summary}*'
    __repr__ = _repr_markdown_

class _GhVerbGroup:
    def __init__(self, verbs):
        self.verbs = verbs
        for o in verbs: setattr(self, o.name, o)
    def _repr_markdown_(self): return "\n".join(f'- {v._repr_markdown_()}' for v in self.verbs)

# Cell
_docroot = 'https://docs.github.com/en/free-pro-team@latest/rest/reference/'

# Cell
class GhApi:
    def __init__(self, owner=None, repo=None, token=None, debug=None, **kwargs):
        self.headers = { 'Accept': 'application/vnd.github.v3+json' }
        if token: self.headers['Authorization'] = 'token ' + token
        if owner: kwargs['owner'] = owner
        if repo:  kwargs['repo' ] = repo
        funcs_ = L(funcs).starmap(_GhVerb, client=self, kwargs=kwargs)
        self.groups = {k.replace('-','_'):_GhVerbGroup(v) for k,v in groupby(funcs_, 'tag').items()}
        self.debug = debug

    def __call__(self, path, verb='GET', headers=None, route=None, query=None, data=None):
        headers = {**self.headers,**(headers or {})}
        if path[:7] not in ('http://','https:/'): path = GH_HOST+path
        return dict2obj(urlsend(path, verb, headers=headers or None, debug=self.debug,
                                route=route or None, query=query or None, data=data or None))

    def __dir__(self): return super().__dir__() + list(self.groups)
    def _repr_markdown_(self): return "\n".join(f'- [{o}]({_docroot+o})' for o in sorted(self.groups))
    def __getattr__(self,k): return self.groups[k] if 'groups' in vars(self) and k in self.groups else stop(AttributeError(k))

    def full_docs(self):
        return '\n'.join(f'## {gn}\n\n{group._repr_markdown_()}\n' for gn,group in sorted(self.groups.items()))

# Cell
@patch
def delete_release(self:GhApi, release):
    "Delete a release and its associated tag"
    self.repos.delete_release(release.id)
    self.git.delete_ref(f'tags/{release.tag_name}')

# Cell
@patch
def _upload_file(self:GhApi, url:str, fn):
    "Upload `fn` to endpoint `url`"
    fn = Path(fn)
    mime = mimetypes.guess_type(fn, False)[0] or 'application/octet-stream'
    headers = {**self.headers, 'Content-Type':mime}
    data = fn.read_bytes()
    return urlsend(url, 'POST', headers=headers, query = {'name':fn.name}, data=data)

# Cell
@patch
def create_release(self:GhApi, tag_name, branch='master', name=None, body='',
                   draft=False, prerelease=False, files=None):
    "Wrapper for `GhApi.repos.create_release` which also uploads `files`"
    if name is None: name = 'v'+tag_name
    rel = self.repos.create_release(tag_name, target_commitish=branch, name=name, body=body,
                                   draft=draft, prerelease=prerelease)
    url = rel.upload_url.replace('{?name,label}','')
    for file in listify(files): self._upload_file(url, file)
    return rel

# Cell
@patch
def list_tags(self:GhApi, prefix:str=''):
    "List all tags, optionally filtered to those starting with `prefix`"
    return self.git.list_matching_refs(f'tags/{prefix}')

# Cell
@patch
def list_branches(self:GhApi, prefix:str=''):
    "List all branches, optionally filtered to those starting with `prefix`"
    return self.git.list_matching_refs(f'heads/{prefix}')

# Cell
# See https://stackoverflow.com/questions/9765453
EMPTY_TREE_SHA = '4b825dc642cb6eb9a060e54bf8d69288fbee4904'

# Cell
@patch
def create_branch_empty(self:GhApi, branch):
    c = api.git.create_commit(f'create {branch}', EMPTY_TREE_SHA)
    return api.git.create_ref(f'refs/heads/{branch}', c.sha)

# Cell
@patch
def delete_tag(self:GhApi, tag:str):
    "Delete a tag"
    return self.git.delete_ref(f'tags/{tag}')

# Cell
@patch
def delete_branch(self:GhApi, branch:str):
    "Delete a branch"
    return self.git.delete_ref(f'heads/{branch}')

# Cell
@patch
def get_branch(self:GhApi, branch=None):
    branch = branch or self.repos.get().default_branch
    return self.list_branches(branch)[0]

# Cell
@patch
def list_files(self:GhApi, branch=None):
    ref = self.get_branch(branch)
    res = self.git.get_tree(ref.object.sha).tree
    return {o.path:o for o in res}

# Cell
@patch
def get_content(self:GhApi, path):
    res = self.repos.get_content(path)
    return base64.b64decode(res.content)

# Cell
@patch
def update_contents(self:GhApi, path, message=None, content=None,
                    sha=None, branch=None, committer=None, author=None):
    if sha is None: sha = api.list_files()[path].sha
    if not isinstance(content,bytes): content = content.encode()
    content = base64.b64encode(content).decode()
    return api.repos.create_or_update_file_contents(path, message, content=content,
        sha=sha, branch=branch, committer=committer, author=author)

# Cell
@patch
def enable_pages(self:GhApi, branch=None, path="/"):
    "Enable or update pages for a repo to point to a `branch` and `path`."
    if path not in ('/docs','/'): raise Exception("path not in ('/docs','/')")
    r = self.repos.get()
    branch = branch or r.default_branch
    source = {"branch": branch, "path": path}
    if r.has_pages: return self.repos.update_information_about_pages_site(source=source)
    if len(self.list_branches(branch))==0: self.create_branch_empty(branch)
    return self.repos.create_pages_site(source=source)

# Cell
def print_summary(req:Request):
    "Print `Request.summary` with the token (if any) removed"
    pprint(req.summary('Authorization'))